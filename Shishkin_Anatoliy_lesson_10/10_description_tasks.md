# Урок 10. Объектно-ориентированное программирование. Продвинутый уровень

## Задание 1
Реализовать класс `Matrix` (матрица). 
* Обеспечить перегрузку конструктора класса (метод `__init__()`), который должен 
  принимать данные (список списков) для формирования матрицы. В случае если список списков некорректный - 
  возбуждать исключение `ValueError` с сообщением `fail initialization matrix`. 

> Подсказка: матрица — система некоторых математических величин, расположенных в виде 
> прямоугольной схемы.

Примеры матриц: 3 на 2, 3 на 3, 2 на 4.

```
| 31 43 |
| 22 51 |
| 37 86 |

| 3 5 32 |
| 2 4 6 |
| -1 64 -8 |
 
| 3 5 8 3 |
| 8 3 7 1 |
```

* Следующий шаг — реализовать перегрузку метода `__str__()` для вывода матрицы в привычном виде (как показано выше).
* Далее реализовать перегрузку метода `__add__()` для сложения двух объектов класса `Matrix` (двух матриц). 
  Результатом сложения должна быть новая матрица.

> Подсказка: сложение элементов матриц выполнять поэлементно. 
> Первый элемент первой строки первой матрицы складываем с первым элементом первой строки второй матрицы и пр.


**ВНИМАНИЕ!** Используйте стартовый код для своей реализации:

```(python)
from typing import List


class Matrix:
    def __init__(self, matrix: List[List[int]]):
        ...


if __name__ == '__main__':
    first_matrix = Matrix([[1, 2], [3, 4], [5, 6]])
    second_matrix = Matrix([[6, 5], [4, 3], [2, 1]])
    print(first_matrix)
    """
    | 1 2 |
    | 3 4 |
    | 5 6 |
    """
    print(first_matrix + second_matrix)
    """
    | 7 7 |
    | 7 7 |
    | 7 7 |
    """
    fail_matrix = Matrix([[1, 2], [3, 4, 7], [5, 6]])
    """
    Traceback (most recent call last):
      ...
    ValueError: fail initialization matrix
    """
```

## Задание 2
Реализовать проект расчёта суммарного расхода ткани на производство одежды. 
Основная сущность этого проекта — одежда (`class Clothes`). 
К типам одежды в этом проекте относятся `пальто` (`class Coat`) и `костюм` (`class Costume`). 
У этих типов одежды существуют параметры: размер `size` (для пальто) и рост `height` (для костюма). 
Значения параметров `size` и `height`, которые они могут принять предусмотреть как `float`.

Для определения расхода ткани по каждому типу одежды использовать формулы: 
* для пальто (`size / 6.5 + 0.5`), 
* для костюма (`2 * height + 0.3`),
* расчёты расхода ткани производить в методе `calculate`, который должен возвращать `float-значение` 
  с количеством знаков после плавающей точки не более двух

Оформить код, используя декоратор абстрактного метода, чтобы регламентировать обязательное определение 
в классах типов одежды метода `calculate`.
Используйте декоратор `@property` для возможности обращения к методу `calculate`, как к атрибуту класса. 


**ВНИМАНИЕ!** Используйте стартовый код для своей реализации:

```(python)

class Clothes: ...
class Coat(Clothes): ...
class Costume(Clothes): ...
    

if __name__ == '__main__':
    coat = Coat(45.0)
    costume = Costume(3)

    print(coat.calculate)  # 7.42
    print(costume.calculate)  # 6.3
```

## Задание 3
Осуществить программу работы с органическими клетками, состоящими из ячеек. 
* Необходимо создать класс `Клетка` (`class Cell`). 
* В его конструкторе инициализировать параметр `cells`, соответствующий количеству ячеек клетки (целое число). 

В классе должны быть реализованы методы перегрузки арифметических операторов: 
* сложение (`__add__()`), 
* вычитание (`__sub__()`), 
* умножение (`__mul__()`), 
* деление (`__truediv__()` и `__floordiv__()`). 
 
Эти методы должны применяться только к клеткам (если это не так, необходимо возбудить исключение 
`TypeError` с сообщением `действие допустимо только для экземпляров того же класса`) и выполнять 
увеличение, уменьшение, умножение и оба вида деления (результаты деления должны возвращать `int-значение`, 
в случае наличия дробной части от деления - отбрасывать её и не учитывать).

**Сложение**. Объединение двух клеток. При этом число ячеек общей клетки должно равняться 
сумме ячеек исходных двух клеток.

**Вычитание**. Участвуют две клетки. Операцию необходимо выполнять, только если разность количества ячеек 
двух клеток больше нуля, иначе возбуждать исключение `ValueError` с сообщением `недопустимая операция`.

**Умножение**. Создаётся общая клетка из двух. 
Число ячеек общей клетки — произведение количества ячеек этих двух клеток.

**Деление**. Создаётся общая клетка из двух. 
Число ячеек общей клетки определяется как целочисленное деление количества ячеек этих двух клеток.

В классе необходимо реализовать метод `make_order()`, принимающий экземпляр класса и количество ячеек в ряду. 
Этот метод позволяет организовать ячейки по рядам. Метод должен возвращать строку вида `*****\n*****\n*** ...`, 
где количество ячеек между `\n` равно переданному аргументу. Если ячеек на формирование ряда не хватает, 
то в последний ряд записываются все оставшиеся.

Например, количество ячеек клетки равняется `12`, а количество ячеек в ряду — `5`. 
В этом случае метод `make_order()` вернёт строку: `*****\n*****\n**`.
Или количество ячеек клетки — `15`, а количество ячеек в ряду равняется `5`. 
Тогда метод `make_order()` вернёт строку: `*****\n*****\n*****`.

> Подсказка: подробный список операторов для перегрузки доступен по [ссылке](https://pythonworld.ru/osnovy/peregruzka-operatorov.html).

**ВНИМАНИЕ!** Используйте стартовый код для своей реализации:

```(python)
class Cell:

    def __init__(self, cells: int):
      ...
      
    def make_order(self, number: int) -> str:
      ...
      
    ...  # реализация других магических методов по заданию
   
if __name__ == '__main__':
    cell_1 = Cell(15)
    cell_2 = Cell(10)
    cell_3 = Cell(3)

    print(cell_1.make_order(10))
    """
    **********
    *****
    """

    sum_cell = cell_2 + cell_3
    print(sum_cell.make_order(6))
    """
    ******
    ******
    *
    """

    sub_cell = cell_1 - cell_3
    print(sub_cell.make_order(6))
    """
    ******
    ******
    """

    mul_cell = cell_2 * cell_3
    print(mul_cell.cells)  # 30

    floordiv_cell = cell_2 // cell_3
    print(floordiv_cell.cells)  # 3

    truediv_cell = cell_1 / cell_2
    print(truediv_cell.cells)  # 1

    try:
        cell_3 - cell_2
    except ValueError as err:
        print(err)  # недопустимая операция

    try:
        cell_1 * 123
    except TypeError as err:
        print(err)  # действие допустимо только для экземпляров того же класса
    
```


